Node.js

Node第一次把JavaScript带入到后端服务器开发
最大的优势是借助JavaScript天生的事件驱动机制加V8高性能引擎，
使编写高性能Web服务轻而易举。
JavaScript语言本身是完善的函数式语言，在前端开发时，
开发人员往往写得比较随意，让人感觉JavaScript就是个“玩具语言”。
但是，在Node环境下，通过模块化的JavaScript代码，加上函数式编程，
并且无需考虑浏览器兼容性问题，直接使用最新的ECMAScript 6标准，
可以完全满足工程上的需求。

1.Node.js安装

  在官网下载压缩包，解压之后将安装目录配置至Path
  在cmd下执行node -v显示版本信息则安装成功

  再次输入node则进入与Node.js的交互环境
  Ctrl+C连续按两次退出交互

2.npm

  npm是Node.js的包管理工具(Package Manager)
  可以通过命令安装其他JS脚本库，不管该脚本在哪，
  直接通过npm安装就可以使用，而且nmp自动解析
  依赖关系并管理依包
   
  安装个淘宝镜像
  npm install -g cnpm --registry=https://registry.npm.taobao.org

3.入门程序

  写一个Hello.js 内容
  'use strict' //使用严格模式
  console.log("Hello!");//打印输出
  在命令行模式下(注意区分Node交互模式)输入命令node Hello.js

  设置Node使用严格模式
  node --use_strict Hello.js

4.模块

  为了维护代码，将函数分组，放到不同的文件中
  在Node环境中，一个.js文件就是一个模块
  模块的名字就是文件名(去掉.js后缀)
  这叫做CommonJS规范

  在模块中对外输出变量:
  在A模块末尾加上module.exports=sayHi(函数名);
  输出的变量可以是任意对象、函数、数组等

  在模块中引入其他变量:
  在B模块中导入:var sayHi = require("./sayHi");
  require中写的是相对路径 ./表示在同一目录下

  在A/B模块中都生命了全局变量但不冲突(
    因为Node在加载时将JS代码包装在了一个函数中，
    所以全局变量互相不冲突
  )
  这种模块加载机制被称为CommonJS规范

  模块导出/入Node实际是这样做的:

   // 准备module对象:
   var module = {
    id: 'hello',
    exports: {}
   };
   var load = function (module) {
    // 读取的hello.js代码:
    function greet(name) {
        console.log('Hello, ' + name + '!');
    }
    //所以在代码中module对象可以直接调用
    module.exports = greet;
    // hello.js代码结束
    return module.exports;
   };
   var exported = load(module);
   // 保存module:
   save(module, exported);
   //交由Node保存 通过require("相对路径")获取对应的module
   //将module中保存的exported返回

   在准备module对象的时候
   exports默认初始化为{} 你可以往里面加东西
   var module = {
    id: 'hello',
    exports: {}
   };

   方式1:(module.)exports.hello=sayHi;

   方式2:module.exports={
      	   sayHi:sayHi,
      	   hi:hi
    		 };
   直接给exports赋值是无效的exoprots={hello:hello};
   因为module是load函数中的一个参数，必须显式调用给其赋值
   若要输出函数/数组，则只能用第二种方式
   Tips：只需要记住第二种方式即可

   1.基本模块

     浏览器中的Window对象，node中:global

     process对象代表当前Node.js的进程
     - process.nextTick(function(){});
       在下一次时间响应中执行代码
     - process.on(exit,function(){ });
       在程序即将退出时执行代码

     判断JS环境
     if(typeof(window)==='undefined'){
         console.log("node.js");
     }else{
         console.log("browser");
     }

   2.内置模块

     -fs模块(文件读写模块)
     
			     a.读取文件
			      异步读取文件 不排队等待IO结束
			      var fs = require('fs');
			      fs.readFile("sample.txt","utf-8",function(err,data){
			        //Node标准的回调函数，err代表错误对象，正确执行时为null
			        //data为读取到的字符串string结果
			        if(!err===null){
								//出错
			        }else{
			          //正常执行
			        }
			      });
			      读取图片文件
			      var buffer = fs.readFile("sample.img",function(err,data){});
			      返回一个Buffer对象 
			      --->Buffer-->String
			          var text = buffer.toString("UTF-8");
			      --->String-->Buffer
			          var buffer = Buffer.from(text,"UTF-8"); 
			      
			      同步读取文件
			      try{
			        var data = fs.readFileSync("sample.txt","UTF-8");
			        console.log(data);
			      }catch(err){
			        console.log(err);
			      }
			      
			     b.写文件
			      异步写文件
			       var fs = require("fs");
			       //如果写入的数据是data则默认是UTF-8
			       var data = "Hello Node.js";
			       fs.writeFile("sample.txt",data,function(err){...});
			      同步写文件
			       类似读取文件
			        fs.writeFileSync("sample.txt",data);
			     
			     获取文件的大小、修改时间、创建时间等信息  
			     fs.stat("sample.txt",function(err,stat){...}); 
			     fs.statSync();
			     fs.size; fs.mtime;fs.birthtime;fs.isFile();fs.isDirectory();
				 
				 判断文件是否存在 fs.access()
			    
			    因为JS只有一个执行线程，因此必须使用异步代码
    
   -stream模块(流) 
    
			    读取文件：
			    var fs = require('fs');
			    打开一个文件输入流
			    var stream = fs.createReadStream("sample.txt","UTF-8");
			    响应流的不同事件
			    data事件：表示已经开始读取(content表示流读取的内容)
			    stream.on("data",function(content){});
			    end事件：表示读取完成
			    stream.on('end',function(){});
			    error事件：表示出错
			    stream.on('error',function(){});
			    
			    写入文件：
			    var stream = createWriteStream("Simple.txt","UFTF-8");
			    stream.write("使用stream写入的数据..\n");
			    stream.write("END");
			    stream.end();
			    
			    pipe(); 复制文件
			    var outputstream = fs.createReadStream("sample.txt","UTF-8");
			    var inputstream = createWriteStream("sample.txt","UTF-8");
			    outputstream.pipe(inputstream);
			    将读取的数据通过流管道传给输入流对象
    
   -http模块:
				非常重要的模块之一，前面有提到，NodeJS将JavaScript引入到后端编程，在我的个人博客中，必不可少的模块，
				 
				NodeJS认真学习，从此模块开始！
				
					Http模块主要用来搭建HTTP服务 最简单的搭建一个HTTP服务非常简单
					
					var http = require('Http')
					// createServer方法返回http.Server对象
					http.createServer(function (request, response) {...}).listen(8080,'127.0.0.1');
					// 传进去的两个对象是请求和响应对象，可以根据该对象的API做一些处理
					console.log('server is running ...');
				
				具体示例参考NodeServerDemo； 下面介绍Request和Response对象
				
				Request对象：
				
					属性：-url 请求的网址，可以被url.prase解析为对象
					
						  -method 请求的方式
						  
						  -headers 请求头信息
						  
					常用方法(具体查看NodeJS文档)：
					
						  -setEncoding("utf8") // 设置请求的编码
						  
						  -addListener('data'/'end', func(){}) // 给对象的事件添加监听
						  
				Respose对象：
				
					是可写流的实现类，因此文件服务器可以用readable.pipe(response)将流注入到响应对象中
					
					常用方法：
					
						-response.end() // 通知服务器响应发送完毕，每次响应都必须调用该方法
						
						-response.setHeader('Content-Type', 'text/html'); // 设置响应头，如果响应头字段存在，则覆盖
						
						-response.writeHeader(statusCode, [Message], [Headers]) // 用于操作响应头 
						
							-res.writeHead(200, { 'Content-Type': 'text/plain' });
							
						-response.write()
					
				Server
				
					事件：
					
						-request (request, response) => {} // 请求连接时触发
						
				
					server对象最常用的方法: server.listen(PORT, HOST); 
					
					另外服务关闭自动重启的方法
					
					server.on('error', (e) => {
					// 当端口被占用  也可以不加该条件，当服务器错误时，1S后重启
						console.log(e.code);
						setTimeout(() => {
						  server.close();
						  server.listen(PORT, HOST);
						}, 1000);
					})
					
					另外server.listening 属性为true表示服务正在监听中..
				
				
 
   -url模块: 
			     var url = require('url');
			     var url = url.parse(url); 解析url为urlJS对象 
			     url.pathname/.query/.href/.path 一般用来解析请求路径，获取其中需要的字段
   -path模块:
			    用来处理本地目录
			    var path = require('path');
			    var a = path.resolve("."); 解析当前目录 d://  具体查看Node.js官方文档
				
					-->疑惑解决：path.resolve('/foo/bar','/temp/file') 返回/temp/file  可以理解为从左到右执行cd命令
					
						即cd /foo/bar  cd /temp/file
					
			    var b ='project'; var filename='hello.html';
			    path.join(a,b,'hello.html'); --> d://project/hello.html
    
  -crypto:提供通用的加密和哈希算法
			    var crypro=require('crypto');
			    var hash = crypto.creatHash("md5");
			    hash.update("");
			    hash.digest("");
    
5.package.json文件
参考：http://javascript.ruanyifeng.com/nodejs/packagejson.html
可以使用npm init自动生成
npm install 命令根据这个文件自动下载所需模块
		   
      -scripts字段 "scripts":{"start":"node hello.js"}
      
		  	指定了npm命令行的缩写
		  	
	  -dependencies字段：指定了项目 运行 所依赖的模块
	  
	  -devDependencies字段：指定了项目 开发 所需要的模块
		  	{
		     "devDependencies": {
		     //版本号的写法说明：a.指定版本 1.2.2 b.~1.2.2表示安装1.2.x的最新 
		     //                              c.^1.2.2 表示安装1.x.x以上  d.latest 最新版本
		     "browserify": "~13.0.0",
		     "karma-browserify": "~5.0.1"
		     }
		    }
		    如果模块不在package.json中可以单独安装
		    npm install babel-cli --save-dev 
		    --save:表示将该模块写入到dependencies属性中
		    --save-dev:表示将该模块写入到devdependencies中
	
	 -main字段
      指定了加载的入口文件，require('moduleName')就会加载这个文件。
      这个字段的默认值是模块根目录下面的index.js。
      
     -style字段
      制定.css文件的路径
   补充：
      
   1.从cnpm install --g --registry=https://registry.npm.taobao.org引发的思考
   
   	--registry参数的作用
   	
   	npm模块仓库提供了一个查询服务，叫做registry,以npmjs.org为例，它的查询网址是：https://registry.npmjs.org/
   	
   	该网址后跟上模块名称，就能得到一个JSON对象，看到该模块所有的版本信息。
   	
   	比如：https://registry.npmjs.org/react/v0.14.6就能得到React的对应版本
   	
   	返回的JSON对象中有dist.tarball属性，是该版本压缩包的网址。
   	dist: {
   	  shasum: '2a57c2cf8747b483759ad8de0fa47fb0c5cf5c6a',
   	  tarball: 'http://registry.npmjs.org/react/-/react-0.14.6.tgz' 
   	},
   	
   	到这个网址下载压缩包在本地解压就得到该模块的源码。
   	
   	npm install和 npm updata都是通过这种方式去安装模块的。
   	
   2.缓存目录
   
   	从registry下载到压缩包之后，都会缓存到本地目录。
   	
   	默认是在用户主目录下的.npm目录中。
   	
   	可以通过npm config ls 查看
   	
   		-->设置全局安装目录和缓存目录
   		
   		缓存目录：通过 npm config set cache "url"来设置缓存目录的路径，此后所有的缓存将放在该目录下 
   		
   		全局安装目录：配置NODE_PATH为该目录路径， 执行 npm config set prefix "url"
   	
   	缓存目录的结构是
   	
   	~/.npm/react/react/0.14.6/
   	~/.npm/react/react/0.14.6/package.tgz
   	~/.npm/react/react/0.14.6/package/
   	~/.npm/react/react/0.14.6/package/package.json
   	
   	此外还会生成registry.npmjs.org/react/.cache.json
   	
   	这个文件保存的是，所有版本的信息，以及该模块最近修改的时间
   	
   	这对于某些操作（npm search/npm view）npm会查看该文件，判断是否需要从远程仓库获取内容
   	
   	清空命令：npm cache clean
   	
   3.模块的安装过程
   
   	1.执行npm install 
   	
   	2.npm 向registry发送查询服务，构建查询网址，获取压缩包
   	
   	3.下载压缩包放在.npm(或者自定义的目录)下
   	
   	4.解压压缩包到当前项目的node_modules目录下
   	
   	也就是说模块安装后本地其实有两份。.npm的压缩包和当前项目的node_modules目录下的解压后的代码
   	
   	问题：npm install 只会检查当前项目的node_modules目录。就算缓存中有 也会重新安装。极大的影响了速度。
   	
   	为了解决这些问题，npm 提供了一个--cache-min参数，用于从缓存目录安装模块。
   
   	--cache-min参数指定一个时间（单位为分钟），只有超过这个时间的模块，才会从 registry 下载。
   	
   	npm install --cache-min 9999999 <package-name> // 指定所有模块从缓存获取
	
6. NodeJS Web 开发！！（来自廖雪峰的官方网站）

	用Node.js开发Web服务器端，有几个显著的优势：

	一是后端语言也是JavaScript，以前掌握了前端JavaScript的开发人员，现在可以同时编写后端代码；

	二是前后端统一使用JavaScript，就没有切换语言的障碍了；

	三是速度快，非常快！这得益于Node.js天生是异步的。
	
	
	-KOA框架：
	
		KOA是Express基于NodeJS的下一代框架
		
		1.安装
		
			npm install --save koa@2.0.0
			
			node必须使用7.6以上的版本
		
		2.基本使用
		
			const Koa = require('koa');
			const app = new Koa();
			app.listen(3000);
			
			这样就启动了一个最简单的服务
			
			Koa提供了一个Context对象，包装了Request和Reponse对象，通过加工这个对象，可以控制返回给用户的内容
			
		3.路由
		
			1.原生路由 ：通过context.request.path来获取用户访问的路由
			
			2.使用koa-route模块
			
			const route = require('koa-route');
			cont home = () => {...};
			app.use(route.get('/', home)); // route.get()方法，传入路由路径，和处理函数
		 
			3.使用koa-static管理静态资源
			
			const serve = require('koa-static');
			const main = serve(path); // serve是一个函数，参数传静态资源的路径，返回一个函数。
			app.use(main);
			
		4.中间件
		
			1.概念理解
		
			const logger = (ctx) => {
				console.log(`${new Date()}  ${ctx.request.method}  ${ctx.request.url}`);
				ctx.response.body = 'Hello world';
			};
			
			这样的一个函数就是中间件，一个输出日志的中间件。它在request和response中间实现某种功能。
			
			每个中间件接收两个参数，第一个参数是Context对象，第二个参数是next函数，只要调用next对象，就可以把执行权限交给下一个中间件。
			
			app.use()方法，就是用来加载中间件！！
			
			
			2.中间件栈
			
				当存在多个中间件时，他们会形成一个栈结构，以先进后出的顺序执行。
				
				当按顺序执行中间件时，遇到next函数，就执行下一个中间件，直到最后一个中间件，再从里到外执行每一个中间件next后面的内容。
				
				如果某个中间件中没有next函数，则执行完该中间件向上依次执行其他中间件next后面的内容。
				
			3.异步中间件
			
				加上async 和 await实现异步中间件
				
			4.中间件的合成
			
				koa-compose模块可以将多个中间件合为一个。
				
				const midware = compose([ ... ]);
				
				一个中间件如果有多个任务要执行，可以拆分为多个小的中间件，再合成之后加载。 合成之后的这个中间件将是一个复杂的中间件！
				
		5.错误处理
			
			context.throw()方法可以抛出错误，可以传递一个错误代码作为参数。
			
			context.throw(500); 服务内部错误；
			
			另外一种抛出错误的方式:
			
				context.response.status = 404; // 等同于：context.throw(404);
				
			-处理错误的中间件
			
				可以让最外层的中间件，负责所有中间件的错误处理
				
				const handler = async (ctx, next) => {
				  try {
					await next();
				  } catch (err) {
					ctx.response.status = err.statusCode || err.status || 500;
					ctx.response.body = {
					  message: err.message
					};
				  }
				};
				
			另外一种处理错误的方式：
			
				当触发错误时，Koa会触发一个error事件，监听该事件去处理错误！
				
				app.on('error', function () {});
				
				需要注意的是如果中间件中有try-catch捕获错误的话，监听error的函数将不会再被调用
				
				但是可以手动释放该错误，让其暴露给外部，触发Koa的error事件。
				
				context.app.emit();手动释放错误。
					
		6.web app的功能
		
			1.cookies  context.cookies; 可以读取cookies;
			
					   context.cookies.get('')  // 获取cookies中的某个字段
					   
					   context.cookies.set('key', value); // 修改cookies
		
					   // 可以测试查看cookies的结构
					   
			2.表单
			
				本质上，表单就是 POST 方法发送到服务器的键值对。
				
				koa-body模块可以从post请求的数据体中提取键值对。
				
				app.use(koaBody()); // 先加载koaBody模块，将数据提取为键值对
				app.use(main);		// 该模块中的context对象的数据被处理为键值对
				
				这个模块还能处理文件上传。 具体参考阮一峰的个人网络日志！
		
	
	
	
	
	
	
	
	
	
	
	
	
	
	
   	